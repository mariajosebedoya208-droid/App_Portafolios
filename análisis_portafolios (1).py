# -*- coding: utf-8 -*-
"""An√°lisis_Portafolios.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OHRI3VCCTIOc3M4eLd18hLDRVqrlBv_n
"""

!pip install streamlit

#Importaci√≥n las librer√≠as

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt

"""En este proyecto se analiza un portafolio de inversi√≥n aplicando la teor√≠a moderna de portafolios de Markowitz.
Se simulan tres escenarios (conservador, moderado y agresivo) para observar c√≥mo var√≠an el riesgo, el rendimiento y la composici√≥n de activos.
Los datos se obtienen directamente desde Yahoo Finance, y los activos seleccionados son empresas tecnol√≥gicas del mercado.
"""

st.title ("üíº Simulaci√≥n de Portafolios de Inversi√≥n")

st.write("Analiza diferentes escenarios (conservador, moderado, agresivo) con datos reales del mercado üìà")

# Lista de tickers

lista_tickers = ['AAPL', 'MSFT', 'META']

print("Activos disponibles:", lista_tickers)

# Selector interactivo

ticker=st.selectbox("Seleccione un ticker", lista_tickers)

# Bot√≥n para descargar los datos

if st.button("Descargar"):
  # Descarga de precios del √∫ltimo mes
    data = yf.download(ticker, period="1mo")
    st.subheader("üìà Datos descargados")
    st.dataframe(data.tail())

# Descarga de datos

data = yf.download(tickers, start='2020-01-01', end='2023-12-31')['Close']

print("‚úÖ Datos descargados correctamente")

# Visualizamos las primeras filas para verificar la estructura de los datos

data.head()

# Visualizaci√≥n de precios

data.plot(figsize=(10,5))
plt.title("Evoluci√≥n hist√≥rica de precios ajustados")
plt.xlabel("Fecha")
plt.ylabel("Precio (USD)")
plt.grid(True)
plt.show()

# C√°lculo de rendimientos y estad√≠sticas b√°sicas

# Rendimientos diarios

returns = data.pct_change().dropna()

print("üìà Rendimientos esperados (anualizados):")
display(mean_returns)

# Rendimientos y covarianza anualizados

mean_returns = returns.mean() * 252
cov_matrix = returns.cov() * 252
volatility = returns.std() * np.sqrt(252)

print("\nüìä Matriz de covarianza (anualizada):")
display(cov_matrix)

# Estad√≠sticas generales
display(returns.describe().T)

#Correclaciones entre activos

corr_matrix = returns.corr()
display(corr_matrix)

plt.figure(figsize=(6,5))
plt.imshow(corr_matrix, cmap='coolwarm', interpolation='nearest')
plt.colorbar(label="Correlaci√≥n")
plt.xticks(range(len(corr_matrix)), corr_matrix.columns, rotation=45)
plt.yticks(range(len(corr_matrix)), corr_matrix.columns)
plt.title("Matriz de correlaci√≥n entre activos")
plt.show()

# Selecci√≥n de escenario

st.subheader("Escenario de inversi√≥n")
escenario = st.selectbox("Seleccione el tipo de portafolio", ["Conservador", "Moderado", "Agresivo"])

# Simulaci√≥n de escenarios

# Definici√≥n de escenarios
escenarios = {
    "Conservador": np.array([0.6, 0.3, 0.1]),
    "Moderado":    np.array([0.4, 0.4, 0.2]),
    "Agresivo":    np.array([0.2, 0.3, 0.5])
}

resultados = []

print("üè¶ Resultados de los escenarios:\n")

if escenario == "Conservador":
    weights = np.array([0.6, 0.3, 0.1])
elif escenario == "Moderado":
    weights = np.array([0.4, 0.4, 0.2])
else:  # Agresivo
    weights = np.array([0.2, 0.3, 0.5])

# Normalizaci√≥n de pesos

weights = weights / np.sum(weights)

# C√°lculo del portafolio

port_return = np.dot(weights, mean_returns)
port_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
sharpe_ratio = port_return / port_volatility

# Resultados

st.subheader("üìä Resultados del escenario seleccionado")
st.write("**Pesos del portafolio:**", dict(zip(lista_tickers, weights.round(2))))
st.write(f"**Rendimiento esperado:** {port_return:.2%}")
st.write(f"**Volatilidad esperada:** {port_volatility:.2%}")
st.write(f"**Ratio de Sharpe:** {sharpe_ratio:.2f}")

# Convertir a DataFrame para an√°lisis

df_resultados = pd.DataFrame(resultados, columns=["Escenario", "Rendimiento", "Riesgo", "Sharpe"])
display(df_resultados)

# Visualizaci√≥n comparativa de los escenarios

plt.figure(figsize=(7,5))
plt.scatter(df_resultados["Riesgo"], df_resultados["Rendimiento"], s=200)

for i in range(len(df_resultados)):
    plt.text(df_resultados["Riesgo"][i]+0.0005,
             df_resultados["Rendimiento"][i],
             df_resultados["Escenario"][i],
             fontsize=12)

plt.title("Comparativo de escenarios de inversi√≥n")
plt.xlabel("Riesgo (Volatilidad)")
plt.ylabel("Rendimiento esperado")
plt.grid(True)
plt.show()

# Distribuci√≥n de pesos por escenario

fig, axs = plt.subplots(1, 3, figsize=(12,4))

for i, (nombre, w) in enumerate(escenarios.items()):
    w = w[:len(returns.columns)]
    w = w / np.sum(w)
    axs[i].pie(w, labels=returns.columns, autopct='%1.1f%%', startangle=90)
    axs[i].set_title(nombre)

plt.suptitle("Distribuci√≥n de pesos por escenario de inversi√≥n")
plt.show()

"""**Conclusiones**

El escenario conservador muestra menor volatilidad y menor rendimiento esperado.

El escenario agresivo ofrece mayor retorno, pero con un incremento notable del riesgo.

El ratio de Sharpe evidencia que el escenario moderado puede ofrecer la mejor relaci√≥n riesgo/retorno.

En general, la simulaci√≥n valida la teor√≠a de Markowitz: la diversificaci√≥n permite ajustar el riesgo y rendimiento seg√∫n el perfil del inversionista.
"""